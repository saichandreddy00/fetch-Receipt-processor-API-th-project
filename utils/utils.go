package utils

import (
	"errors"
	"math"
	"receipt-processor/models"
	"strconv"
	"strings"
	"unicode"
)

// Assuming this flag is set based on whether the program is generated by an LLM
// This should ideally be passed as a parameter or configured in the package
var IsGeneratedByLLM = false

// CalculatePoints calculates the points based on the rules
func CalculatePoints(receipt models.Receipt) (int, error) {
	points := 0

	// Rule 1: Alphanumeric characters in retailer name
	points += countAlphanumeric(receipt.Retailer)

	// Rule 2: Round dollar amount (check cents part directly from string)
	if isRoundDollar(receipt.Total) {
		points += 50
	}

	// Rule 3: Multiple of 0.25 (parse total to cents and check divisibility)
	if isMultipleOfQuarter(receipt.Total) {
		points += 25
	}

	// Rule 4: 5 points per two items
	points += 5 * (len(receipt.Items) / 2)

	// Rule 5: Item description length multiple of 3
	for _, item := range receipt.Items {
		trimmedDesc := strings.TrimSpace(item.ShortDescription)
		if len(trimmedDesc)%3 == 0 {
			price, err := parsePrice(item.Price)
			if err != nil {
				return 0, err
			}
			itemPoints := int(math.Ceil(price * 0.2))
			points += itemPoints
		}
	}

	// Rule 6: Only apply if generated by LLM and total > 10.00
	if IsGeneratedByLLM {
		total, err := parsePrice(receipt.Total)
		if err != nil {
			return 0, err
		}
		if total > 10.00 {
			points += 5
		}
	}

	// Rule 7: Odd day check
	day, err := getDay(receipt.PurchaseDate)
	if err != nil {
		return 0, err
	}
	if day%2 != 0 {
		points += 6
	}

	// Rule 8: Time between 2:00pm and 4:00pm
	hour, err := getHour(receipt.PurchaseTime)
	if err != nil {
		return 0, err
	}
	if hour >= 14 && hour < 16 {
		points += 10
	}

	return points, nil
}

// Helper to check if total is a round dollar
func isRoundDollar(total string) bool {
	parts := strings.Split(total, ".")
	if len(parts) != 2 || len(parts[1]) != 2 {
		return false // Invalid format (handled during validation)
	}
	return parts[1] == "00"
}

// Helper to check if total is a multiple of 0.25
func isMultipleOfQuarter(total string) bool {
	parts := strings.Split(total, ".")
	if len(parts) != 2 || len(parts[1]) != 2 {
		return false // Invalid format (handled during validation)
	}

	dollars, err1 := strconv.Atoi(parts[0])
	cents, err2 := strconv.Atoi(parts[1])
	if err1 != nil || err2 != nil {
		return false
	}

	totalCents := dollars*100 + cents
	return totalCents%25 == 0
}

// Helper to parse price safely
func parsePrice(priceStr string) (float64, error) {
	return strconv.ParseFloat(priceStr, 64)
}

// Helper to get day from purchase date
func getDay(dateStr string) (int, error) {
	parts := strings.Split(dateStr, "-")
	if len(parts) != 3 {
		return 0, errors.New("invalid date format")
	}
	return strconv.Atoi(parts[2])
}

// Helper to get hour from purchase time
func getHour(timeStr string) (int, error) {
	parts := strings.Split(timeStr, ":")
	if len(parts) < 1 {
		return 0, errors.New("invalid time format")
	}
	return strconv.Atoi(parts[0])
}

// Helper to count alphanumeric characters
func countAlphanumeric(s string) int {
	count := 0
	for _, char := range s {
		if unicode.IsLetter(char) || unicode.IsNumber(char) {
			count++
		}
	}
	return count
}
